---
title: "Chapter03 Operating System"
excerpt: "Chapter03. System Programming"

categories:
  - SystemProgramming
tags:
  - [SystemProgramming]

permalink: /categories/SystemProgramming/Chapter03

toc: true
toc_sticky: true

date: 2025-04-26
last_modified_at: 2025-04-26
---

# Chapter 4: OS 핵심 알고리즘 및 운영체제 배경 기술

## 1. 운영체제의 핵심 기술
- 1-1. 프로세스와 스레드
- 1-2. 멀티프로세싱, 멀티태스킹, 멀티스레딩
- 1-3. 전경/배경 시스템 개념 및 ISR

## 2. 운영체제의 배경 기술
- 2-1. 크리티컬 섹션과 상호배제(Mutual Exclusion)
- 2-2. 공유자원 관리
- 2-3. 멀티태스킹과 문맥전환(Context Switch)
- 2-4. 태스크(Task)의 상태 및 구조
- 2-5. 스택과 힙
- 2-6. 커널의 정의와 기능
- 2-7. 스케줄러와 커널의 유형 (선점형, 비선점형)
- 2-8. 우선순위 관리 (정적, 동적 우선순위)

## 3. 동기화 메커니즘
- 3-1. 세마포어(Semaphore) 정의와 종류 (바이너리, 카운팅)
- 3-2. 세마포어 연산 (Wait/Pend, Signal/Post)
- 3-3. 세마포어의 캡슐화, 예시 및 실용 사례

## 4. 상호배제 구현 방법
- 4-1. 인터럽트 비활성화/활성화
- 4-2. Test-And-Set(TAS)
- 4-3. 스케줄러 비활성화

## 5. 교착상태(Deadlock)
- 5-1. 교착상태의 정의와 조건
- 5-2. 교착상태 방지 및 해결 방안

## 6. 동기화(Synchronization)
- 6-1. 일방집결 (Unilateral Rendezvous)
- 6-2. 양방집결 (Bilateral Rendezvous)
- 6-3. ISR과의 동기화 한계

## 7. 스케줄링 기법
- 7-1. 라운드 로빈 스케줄링 (Round-Robin)
- 7-2. RMS (Rate Monotonic Scheduling) 알고리즘
  - 7-2-1. RMS 개요 및 가정
  - 7-2-2. 수식 및 Utilization Factor 계산
  - 7-2-3. 예제 (T1, T2, T3 주기 및 실행 시간표)

## 8. 실습 계획
- 8-1. Laboratory session syllabus

---

# Chapter 4: OS 핵심 알고리즘 및 운영체제 배경 기술

## 1. 운영체제의 핵심 기술

### 1-1. 프로세스와 스레드
- **프로세스(Process)**: OS에서 실행 중인 프로그램 단위. 일반적으로 하나의 주소 공간을 가짐.
- **스레드(Thread)**: 프로세스 내에서 실행되는 **작업 단위**. 동일한 메모리 공간을 공유하며, 가벼운 프로세스로 간주됨.
- **Task**: 스레드와 동일한 개념으로, **RTOS 환경에서는 주로 Task라고 부름**.

### 1-2. 멀티프로세싱 / 멀티태스킹 / 멀티스레딩
- **멀티프로세싱**: 여러 CPU가 동시에 작업을 수행.
- **멀티태스킹**: 하나의 CPU가 스케줄링을 통해 여러 작업을 번갈아 수행.
- **멀티스레딩**: 하나의 CPU 내에서 여러 스레드가 동시에 실행되는 것처럼 보이도록 수행.

### 1-3. 전경/배경 시스템 및 ISR
- **Foreground/Background 시스템**: 
  - C 언어 실습에서의 **무한 루프 기반 시스템**.
  - 전경(Foreground): 사용자 입력 및 이벤트 등 **보이는 부분**.
  - 배경(Background): 내부 루프에서 반복적으로 처리하는 **비동기 동작**.
- **ISR (Interrupt Service Routine)**: 
  - 이벤트 발생 시 **즉시 실행되는 루틴**.
  - **중요한 동작은 반드시 ISR에서 처리해야 하며**, 응답 시간에 따라 시스템 신뢰도가 결정됨.
- **태스크레벨 응답시간**: 배경 루프를 한 바퀴 도는 데 걸리는 시간에 의해 결정됨.

---

## 2. 운영체제의 배경 기술

### 2-1. 크리티컬 섹션(Critical Section)
- **동시에 접근하면 안 되는 공유 자원을 다루는 코드 영역**.
- **인터럽트로 분리되어 중단되면 안 되며**, 실행 전후로 인터럽트를 비활성/활성화하여 보호해야 함.

### 2-2. 공유자원 관리
- **Shared Resource**: 여러 태스크가 공유하여 사용하는 자원.
- **상호배제(Mutual Exclusion)** 필요 → 데이터 손상 방지.

### 2-3. 멀티태스킹과 문맥전환
- **멀티태스킹**: 여러 태스크가 CPU를 번갈아 사용하는 시스템.
- **문맥전환(Context Switch)**: 실행 중인 태스크의 상태를 저장하고, 다른 태스크의 상태로 전환하는 과정.
  - **레지스터 상태를 스택에 저장 후 교체**, 오버헤드 발생 가능.

### 2-4. 태스크(Task)의 상태
- DORMANT(수면 상태)
- READY(실행 대기)
- RUNNING(실행 중)
- WAITING(이벤트 대기)
- ISR(인터럽트 서비스 루틴)

### 2-5. 스택과 힙
- **스택**: 함수 호출 시 생성되는 메모리, **LIFO 구조**, 지역 변수 저장.
- **힙**: **동적 메모리 할당**을 위한 영역. 수명과 위치는 사용자 제어.

### 2-6. 커널(Kernel)의 정의
- **운영체제의 핵심 구성 요소**, 태스크 관리 및 문맥전환 수행.
- **각 태스크는 고유한 스택 공간을 가지며**, RAM 소비량 증가의 원인.
- 일반적으로 CPU 사용률의 2~5% 사용.

### 2-7. 스케줄러(Scheduler)
- **디스패처(Dispatcher)**라고도 불리며, 다음에 실행될 태스크를 결정.
- **우선순위 기반 실행**.
- **스케줄러 유형**:
  - **비선점형(Non-Preemptive)**: 명시적으로 CPU 제어권을 넘겨야 함.
  - **선점형(Preemptive)**: 더 높은 우선순위 태스크가 등장하면 즉시 문맥전환.

### 2-8. 우선순위 관리
- **정적 우선순위**: 컴파일 시 결정, 변경 불가.
- **동적 우선순위**: 실행 중 변경 가능. **우선순위 역전 현상 해결 가능**.

---

## 3. 동기화 메커니즘

### 3-1. 세마포어(Semaphore)의 정의 및 종류
- **세마포어(Semaphore)**: 
  - 1960년대 중반 Edsger Dijkstra가 제안한 동기화 도구.
  - **Mutual Exclusion (상호 배제)**, **Signaling (이벤트 통보)**, **Synchronization (동기화)** 기능 제공.
- **종류**:
  - **바이너리 세마포어**: 값이 0 또는 1 → 공유 자원 접근 통제.
  - **카운팅 세마포어**: 값이 0 이상 정수 → 다수 자원 동시 사용 (예: 버퍼풀 등).

### 3-2. 세마포어 동작 방식
- **Initialize/Create**: 세마포어 생성 및 초기화.
- **Wait (PEND)**:
  - 세마포어 값 > 0 → 값 감소 후 태스크 실행 계속.
  - 세마포어 값 = 0 → 태스크는 **대기 목록에 들어가며 Block 상태**로 진입.
- **Signal (POST)**:
  - 대기 태스크 없음 → 세마포어 값 1 증가.
  - 대기 중인 태스크 있음 → 가장 높은 우선순위 또는 FIFO 방식으로 하나를 깨움.

> 💡 대부분의 커널은 Wait 연산 시 **타임아웃 설정**이 가능하며, 실패 시 에러 코드 반환.

### 3-3. 세마포어 캡슐화 및 활용 예시
- **세마포어 캡슐화**:
  - 자원 접근 함수 내부에서 세마포어 획득 및 해제를 수행.
  - 사용자는 내부적으로 세마포어가 사용되는지 몰라도 됨.
- **예시**:
  - `CommSendCmd()` 함수 → 포트 세마포어를 자동 획득하고, 명령 전송 후 응답 대기.

- **공유 자원 예시**:
  - 프린터 출력 시 태스크들이 동시에 출력 요청할 경우, 글자가 섞이는 문제 발생.
  - → 바이너리 세마포어로 출력 권한을 하나의 태스크에만 부여.

- **버퍼풀 예시**:
  - 초기 버퍼 10개 → 카운팅 세마포어 10으로 초기화.
  - 태스크가 `BufReq()`로 요청하고 `BufRel()`로 반납.

- **세마포어 사용 시 주의점**:
  - 간단한 공유 변수 제어에는 세마포어 사용이 **오버헤드가 큼**.
  - 이 경우는 **인터럽트 비활성화 방식**이 더 적절할 수 있음.

---

## 4. 상호배제 구현 방법

### 4-1. 인터럽트 비활성화 / 활성화
- **가장 단순하고 빠른 방법**.
- 공유 자원 접근 전에 인터럽트를 비활성화하고, 종료 후 다시 활성화.
- **단점**: 비활성화 시간이 길면 시스템 응답성 저하 발생 (→ 인터럽트 지연 시간 증가).

### 4-2. Test-And-Set (TAS) 오퍼레이션
- 전역 변수의 값을 검사하여 상호배제를 구현.
- 변수 값이 0일 경우 → 자원 접근, 동시에 1로 세팅하여 다른 접근 차단.
- TAS 오퍼레이션은 **인터럽트에 의해 중단되지 않도록 실행**되어야 함.

### 4-3. 스케줄러 비활성화
- 태스크 간 경쟁 자원 접근 제어에 사용 가능.
- **ISR과 공유되지 않는 자원일 때**만 사용해야 함.
- 스케줄러 비활성화 상태에서도 인터럽트는 작동함.
- **문제점**:
  - 스케줄러가 중단되어도 ISR이 새로운 태스크를 실행 준비 상태로 만들 수 있음.
  - 스케줄러를 재활성화하면 문맥 전환이 일어나고, 원치 않는 실행 흐름이 발생할 수 있음.
  - 따라서 **스케줄러 비활성화는 커널 설계 철학에 위배**되므로 가급적 피해야 함.

---

## 5. 교착상태 (Deadlock)

### 5-1. 교착상태의 정의
- **교착상태(Deadlock)**:
  - 영어로는 **Deadly Embrace**라고도 불림.
  - 두 개 이상의 태스크가 서로가 가진 자원을 **무한히 기다리며 진행이 멈추는 상태**.
- **예시**:
  - 태스크 T1: 자원 R1 보유, R2 필요
  - 태스크 T2: 자원 R2 보유, R1 필요
  - → 서로 자원을 획득하지 못한 채 **무한 대기 상태** 진입 → 교착상태 발생

### 5-2. 교착상태 방지 방법
- **자원을 모두 확보한 후 실행 시작** (All-at-once)
- **획득 순서를 명시** (Ordered Resource Allocation)
- **반납도 획득한 순서의 역순으로** (Reverse Release)

### 5-3. 타임아웃 기반 회피
- 대부분의 커널은 **세마포어 획득 시 타임아웃 기능 제공**.
  - 일정 시간 내 세마포어 획득 실패 시 → 대기 탈출, 에러코드 반환.
- 이 기능을 활용해 **교착상태를 예방할 수 있음**.

> 💡 일반적으로 **교착상태는 대화형 멀티태스킹 시스템**에서 더 자주 발생.  
> 임베디드 시스템에서는 예측 가능한 태스크만 존재하므로 **사전 예방 설계**가 더 중요.

---

## 6. 동기화 (Synchronization)

### 6-1. 일방집결 (Unilateral Rendezvous)
- 세마포어 초기값: `0`
- 태스크는 I/O 요청 후 세마포어를 기다림 (`WAIT`)
- ISR이 완료 시 세마포어에 신호 (`SIGNAL`) → 태스크가 다시 실행됨
- **일방향 동기화**: 태스크 → ISR 순서

### 6-2. 양방집결 (Bilateral Rendezvous)
- 양쪽 태스크가 **서로 동기화가 되어야 진행**.
- 각각 세마포어를 대기하고 상대방이 신호를 보낼 때까지 대기.
- 양쪽 태스크 모두 세마포어를 사용하여 서로 진행을 통제.

> ❗ ISR은 세마포어를 기다릴 수 없기 때문에 **ISR과의 양방집결은 불가능**.

---

## 7. 스케줄링 기법

### 7-1. 라운드 로빈 스케줄링 (Round-Robin)
- **가장 기본적인 스케줄링 방법**.
- 태스크에 **동일한 시간 할당량(Time Slice)** 을 부여하며 순차적으로 실행.
- **응답 시간이 느린 대신**, 단순하고 구현이 쉬움.
- **장점**: 태스크 간 공정성 보장.
- **단점**: 높은 응답성이 필요한 시스템에는 적합하지 않음.

---

### 7-2. RMS (Rate Monotonic Scheduling)

#### 7-2-1. 개요 및 가정
- 1973년 Liu & Layland 제안.
- **실시간 시스템을 위한 정적 스케줄링 알고리즘**.
- 수행 주기가 짧은 태스크일수록 높은 우선순위를 부여.

**가정 조건:**
1. 모든 태스크는 **주기적**이다.
2. 태스크들은 **동기화되지 않고**, 자원을 공유하지 않는다.
3. **선점형 커널** 환경에서 사용된다.

#### 7-2-2. RMS 수식 및 한계

> 하드 실시간 조건을 만족시키기 위한 **CPU 사용률 조건**:

$$
\sum_{i=1}^{n} \frac{E_i}{T_i} \leq n(2^{1/n} - 1)
$$

- \( E_i \): i번째 태스크의 최대 실행 시간
- \( T_i \): i번째 태스크의 주기
- n: 태스크 개수

→ n이 커질수록 우변은 약 0.693로 수렴 → **CPU 사용률이 69.3% 이하**이어야 모든 태스크가 시간 내 완료됨을 보장.

#### 7-2-3. 예제

| 순번 | 태스크 | 실행 시간(E) | 주기(T) |
|------|--------|---------------|----------|
| 1    | T1     | 2             | 5        |
| 2    | T2     | 4             | 7        |

- \( \frac{2}{5} + \frac{4}{7} \approx 0.971 \) → 0.693 초과 → RMS 기준으로는 실패 (단, 실제 실행은 가능할 수 있음)

> ✅ RMS는 이론적인 기준선이며, **70% 이내이면 안전**, 그 이상은 **케이스 별 실험 필요**.

---

