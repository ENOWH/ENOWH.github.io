---
title: "DDS_Chap06_Behavioral Design"
excerpt: "Chapter06_Behavioral Design"

categories:
  - DesignOfDigitalSystem
tags:
  - [Design Of Digital System]

permalink: /categories/DDS/Chapter06_DSS

toc: true
toc_sticky: true

date: 2025-05-27
last_modified_at: 2025-05-27
---

# 1. Introduction â€“ Behavioral Level Design

## âœ… ì£¼ìš” ê°œë… íë¦„
- **Behavioral Design**ì€ ë””ì§€í„¸ ì‹œìŠ¤í…œì˜ ê¸°ëŠ¥ê³¼ ë™ì‘ì„ ì¤‘ì‹¬ìœ¼ë¡œ **ê°€ì¥ ì¶”ìƒì ì¸ ìˆ˜ì¤€ì—ì„œ ì„¤ê³„**ë¥¼ í‘œí˜„í•˜ëŠ” ë°©ì‹ì´ë‹¤.
- ì¼ë°˜ì ìœ¼ë¡œ **ì•Œê³ ë¦¬ì¦˜ì  ë˜ëŠ” ê¸°ëŠ¥ì  ë ˆë²¨**ì˜ ë™ì‘ì„ Verilogë¡œ ê¸°ìˆ í•˜ë©°, ì´ëŠ” C ì–¸ì–´ì™€ ìœ ì‚¬í•œ êµ¬ë¬¸ì„ ê°€ì§„ë‹¤.
- ì´ ë ˆë²¨ì˜ ì„¤ê³„ëŠ” ì‹œë®¬ë ˆì´ì…˜ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ **í•©ì„±(synthesis)**ì´ ë¶ˆê°€ëŠ¥í•˜ê±°ë‚˜, í•©ì„±í•˜ë”ë¼ë„ **ë¹„íš¨ìœ¨ì ì¸ íšŒë¡œ**ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
- ë”°ë¼ì„œ ì‹¤ì œ êµ¬í˜„ì„ ìœ„í•´ì„œëŠ” RTL(ë ˆì§€ìŠ¤í„° ì „ì†¡ ìˆ˜ì¤€) ì„¤ê³„ë¡œ ì„¸ë¶„í™”ê°€ í•„ìš”í•˜ë‹¤.

---

## âœ… í•µì‹¬ ê°œë… ì •ë¦¬

### ğŸ¯ Behavioral Designì˜ íŠ¹ì§•
- **ê°€ì¥ ì¶”ìƒì ì¸ ìˆ˜ì¤€**ì˜ ì„¤ê³„ í‘œí˜„ (system algorithm level)
- **Verilog behavioral constructs** ì‚¬ìš© (`initial`, `always` ë“±)
- **í•©ì„± ë¶ˆê°€** í˜¹ì€ **ë¹„ìµœì  íšŒë¡œ** ìƒì„± ê°€ëŠ¥ì„± ìˆìŒ
- RTL ìˆ˜ì¤€ì˜ êµ¬ì²´ì  ì„¤ê³„ê°€ í•„ìš”í•¨

---

## âœ… ì„¤ê³„ ê´€ì  ìš”ì•½

| êµ¬ë¶„ | Behavioral Level | RTL Level |
|------|------------------|-----------|
| ì¶”ìƒí™” ìˆ˜ì¤€ | ë§¤ìš° ë†’ìŒ | ì¤‘ê°„ |
| ëª©ì  | ì‹œë®¬ë ˆì´ì…˜, ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸ | ì‹¤ì œ í•˜ë“œì›¨ì–´ í•©ì„± |
| ì˜ˆì‹œ | `initial`, `always` ë¸”ë¡ ì¤‘ì‹¬ | `always @`, reg/wire ì—°ê²° |
| í•©ì„± ê°€ëŠ¥ ì—¬ë¶€ | ëŒ€ë¶€ë¶„ ë¶ˆê°€ ë˜ëŠ” ë¹„íš¨ìœ¨ | í•©ì„± ìµœì í™” ê°€ëŠ¥ |

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸
- Behavioral levelì€ Verilogì˜ `initial`, `always` ë¸”ë¡ì„ ì´ìš©í•˜ì—¬ ë™ì‘ì„ ì¶”ìƒì ìœ¼ë¡œ ê¸°ìˆ í•˜ëŠ” ë°©ì‹
- í…ŒìŠ¤íŠ¸ë²¤ì¹˜ë‚˜ ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ìœ ìš©í•˜ì§€ë§Œ, ì‹¤ì œ íšŒë¡œ êµ¬í˜„ì„ ìœ„í•´ì„œëŠ” RTL ì„¤ê³„ë¡œ ì„¸ë¶„í™”ê°€ í•„ìš”

---

# 2. Structured Procedures â€“ initial & always blocks

## âœ… ì£¼ìš” ê°œë… íë¦„
Verilogì˜ behavioral ì„¤ê³„ëŠ” ë‘ ê°€ì§€ **ì ˆì°¨ì  ë¸”ë¡(procedural blocks)**ì„ í†µí•´ êµ¬ì„±ëœë‹¤:
- `initial` ë¸”ë¡: **í•œ ë²ˆë§Œ ì‹¤í–‰**, ì‹œë®¬ë ˆì´ì…˜ ì´ˆê¸°í™” ë˜ëŠ” í…ŒìŠ¤íŠ¸ë²¤ì¹˜ì— ì‚¬ìš©
- `always` ë¸”ë¡: **ë°˜ë³µ ì‹¤í–‰**, ë™ì‘(behavior) í‘œí˜„, í•©ì„± ê°€ëŠ¥í•œ ë¸”ë¡

ì´ ë‘ ë¸”ë¡ì€ behavioral ëª¨ë¸ë§ì˜ í•µì‹¬ì´ë©°, ëª¨ë“  ì ˆì°¨ì  ë¬¸ì¥ì€ ë°˜ë“œì‹œ ì´ë“¤ ì•ˆì— í¬í•¨ë˜ì–´ì•¼ í•œë‹¤.

---

## âœ… í•µì‹¬ ë¬¸ë²•

### ğŸ¯ initial block
```verilog
initial begin
  // ì´ˆê¸°í™”ìš© ì½”ë“œ
end
```

- ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ì‹œ **í•œ ë²ˆë§Œ ì‹¤í–‰**
- ì—¬ëŸ¬ ê°œì˜ `initial` ë¸”ë¡ì„ ë™ì‹œì— ì„ ì–¸ ê°€ëŠ¥ (ë³‘ë ¬ ì‹¤í–‰)
- **ì´ˆê¸°í™”, í…ŒìŠ¤íŠ¸ë²¤ì¹˜ ì‘ì„±ì— ìœ ìš©**
- ëŒ€ë¶€ë¶„ **í•©ì„± ë¶ˆê°€ëŠ¥**

---

### ğŸ¯ always block
```verilog
always @(sensitivity_list) begin
  // ë°˜ë³µ ì‹¤í–‰ ì½”ë“œ
end
```

- ê°ì§€ ë¦¬ìŠ¤íŠ¸ (`@`)ì˜ ë³€í™”ê°€ ìƒê¸°ë©´ ë¸”ë¡ ì‹¤í–‰
- ì˜ˆì‹œ:
  - `@(posedge clk)` : ìƒìŠ¹ì—£ì§€ì—ì„œ ì‹¤í–‰ (ë™ê¸°ì‹ íšŒë¡œ)
  - `@(*)` ë˜ëŠ” `@*` : ì¡°í•©íšŒë¡œì—ì„œ ì‚¬ìš© (ìë™ ê°ì§€ ë¦¬ìŠ¤íŠ¸)
- **í•©ì„± ê°€ëŠ¥**

---

### ğŸ¯ beginâ€“end ë¸”ë¡ êµ¬ì¡°

- **ë‹¨ì¼ ë¬¸ì¥**ì´ë©´ `beginâ€“end` ìƒëµ ê°€ëŠ¥
- **ì—¬ëŸ¬ ë¬¸ì¥**ì´ë©´ ë°˜ë“œì‹œ `begin ... end`ë¡œ ë¬¶ì–´ì•¼ í•¨

```verilog
always @(a or b) begin
  out1 = a & b;
  out2 = a | b;
end
```

---

## âœ… ì˜ˆì‹œ: ë³‘ë ¬ initial ë¸”ë¡
```verilog
initial a = 1'b0;

initial begin
  #10 b = 1'b1;
  #30 c = 1'b0;
end

initial begin
  #40 x = 1'b0;
  #50 y = 1'b1;
end
```
- `a`, `b`, `c`, `x`, `y`ëŠ” ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ì— ë”°ë¼ **ë³‘ë ¬ë¡œ ë³€í™”**

---

## âœ… ì˜ˆì‹œ: clock ìƒì„±ê¸°
```verilog
module clock_gen(output reg clock);

initial clock = 1'b0;
always #10 clock = ~clock;  // 20ns period clock

endmodule
```

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| ë¸”ë¡ ì¢…ë¥˜   | ì‹¤í–‰ ì‹œì   | ë°˜ë³µ ì—¬ë¶€ | ì£¼ ìš©ë„                   | í•©ì„± ê°€ëŠ¥ ì—¬ë¶€ |
|------------|------------|-----------|----------------------------|----------------|
| `initial`  | time 0     | âŒ (1íšŒ)  | ì´ˆê¸°í™”, í…ŒìŠ¤íŠ¸ë²¤ì¹˜         | âœ– (ê±°ì˜ ë¶ˆê°€)   |
| `always`   | event ë°œìƒ | â­• (ë°˜ë³µ) | ë™ì‘ ì •ì˜ (behavioral/RTL) | â­• (ê°€ëŠ¥)       |

> âœ… ëª¨ë“  behavioral êµ¬ë¬¸ì€ ë°˜ë“œì‹œ `initial` ë˜ëŠ” `always` ë¸”ë¡ ë‚´ë¶€ì— ì‘ì„±ë˜ì–´ì•¼ í•œë‹¤.

---

# 3. Procedural Assignments â€“ Blocking vs Non-blocking

## âœ… ì£¼ìš” ê°œë… íë¦„
Verilogì—ì„œ ë³€ìˆ˜ì— ê°’ì„ í• ë‹¹í•  ë•Œ ì‚¬ìš©í•˜ëŠ” **ì ˆì°¨ì  í• ë‹¹(procedural assignment)**ì€ ë‘ ê°€ì§€ ë°©ì‹ì´ ìˆë‹¤:
- **Blocking assignment (`=`)**: Cì²˜ëŸ¼ **ìˆœì°¨ ì‹¤í–‰**
- **Non-blocking assignment (`<=`)**: ë³‘ë ¬ ì‹¤í–‰ ëª¨ë¸ë§ì— ì í•©, **íŒŒì´í”„ë¼ì¸** íšŒë¡œ ì„¤ê³„ì— ì‚¬ìš©

ë‘ ë°©ì‹ì€ **ë™ì‘ ì˜ë¯¸ì™€ í•©ì„± ê²°ê³¼ ëª¨ë‘ ë‹¤ë¥´ê¸° ë•Œë¬¸ì—**, ê°™ì€ ë¸”ë¡ ì•ˆì—ì„œ í˜¼ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ë‹¤.

---

## âœ… ê¸°ë³¸ ë¬¸ë²•

### ğŸ¯ Blocking assignment (ìˆœì°¨ ì‹¤í–‰)
```verilog
a = b + c;
```
- ì• ë¬¸ì¥ì´ **ì™„ì „íˆ ëë‚˜ì•¼ ë‹¤ìŒ ë¬¸ì¥ ì‹¤í–‰**
- C ì–¸ì–´ì²˜ëŸ¼ ë™ì‘
- **ì¡°í•©íšŒë¡œ(combinational logic)** ì„¤ê³„ì— ì£¼ë¡œ ì‚¬ìš©
- `=` ì—°ì‚°ì ì‚¬ìš©

---

### ğŸ¯ Non-blocking assignment (ë³‘ë ¬ ì‹¤í–‰)
```verilog
a <= b + c;
```
- **ì˜¤ë¥¸ìª½ ê°’(RHS)**ë§Œ ë¨¼ì € í‰ê°€ â†’ **ëª¨ë“  LHSì— ë™ì‹œì— í• ë‹¹**
- **ë™ê¸°ì‹ íšŒë¡œ(sequential logic)** ì„¤ê³„ì— ì‚¬ìš©
- **ë ˆì§€ìŠ¤í„°**, íŒŒì´í”„ë¼ì¸ êµ¬ì¡°, ë™ê¸° ë°ì´í„° ì´ë™ ë“±
- `<=` ì—°ì‚°ì ì‚¬ìš©

---

## âœ… ì˜ˆì‹œ 1: Blocking â€“ ì¡°í•© ë…¼ë¦¬
```verilog
module addtree(output reg [9:0] out,
               input [7:0] in1, in2, in3, in4);

reg [8:0] part1, part2;
always @(in1, in2, in3, in4) begin
  part1 = in1 + in2;
  part2 = in3 + in4;
  out = part1 + part2;
end
endmodule
```

---

## âœ… ì˜ˆì‹œ 2: Non-blocking â€“ í”Œë¦½í”Œë¡­/ë ˆì§€ìŠ¤í„°
```verilog
module swap(output reg out0, out1, input rst, clk);
always @(posedge clk) begin
  if (rst) begin
    out0 <= 1'b0;
    out1 <= 1'b1;
  end else begin
    out0 <= out1;
    out1 <= out0;
  end
end
endmodule
```

---

## âœ… ì˜ˆì‹œ 3: Race condition ë¹„êµ
```verilog
// ë‚˜ìœ ì˜ˆ (race condition)
always @(posedge clk) a = b;
always @(posedge clk) b = a;

// ì¢‹ì€ ì˜ˆ (non-blocking â†’ ì•ˆì •ì )
always @(posedge clk) a <= b;
always @(posedge clk) b <= a;
```

---

## âœ… ì˜ˆì‹œ 4: Temp ë³€ìˆ˜ë¡œ non-blockingì„ blockingìœ¼ë¡œ í‰ë‚´ë‚´ê¸°
```verilog
always @(posedge clk) begin
  temp_a = a;
  temp_b = b;
  a = temp_b;
  b = temp_a;
end
```

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| êµ¬ë¶„             | Blocking (`=`)               | Non-blocking (`<=`)              |
|------------------|------------------------------|----------------------------------|
| ì‹¤í–‰ ë°©ì‹        | ìˆœì°¨ì  (statement by statement) | ë³‘ë ¬ì  (ëª¨ë‘ RHS í‰ê°€ í›„ LHSì— ë™ì‹œ í• ë‹¹) |
| ìš©ë„             | ì¡°í•© ë…¼ë¦¬                    | ìˆœì°¨ ë…¼ë¦¬ (ë ˆì§€ìŠ¤í„°, FF)         |
| ì‚¬ìš© ì‹œì         | `always @(*)` ë¸”ë¡ ë“±         | `always @(posedge clk)` ë¸”ë¡ ë“± |
| ì£¼ì˜ì‚¬í•­         | ìˆœì„œ ë¯¼ê°, race ë°œìƒ ê°€ëŠ¥     | race condition ë°©ì§€ì— ìœ ë¦¬       |
| í˜¼ìš© ê¸ˆì§€ ì›ì¹™   | ê°™ì€ always ë¸”ë¡ì—ì„œ í˜¼ìš© âŒ  | ë°˜ë“œì‹œ ë¶„ë¦¬í•´ì„œ ì‘ì„±í•  ê²ƒ        |

> âœ… ì‹¤ì œ íšŒë¡œ í•©ì„±ì—ì„œëŠ” `<=`ë¥¼ FFì—, `=`ë¥¼ ì¡°í•© ë…¼ë¦¬ì— ì‚¬ìš©í•˜ì!

---

# 4. Timing Controls â€“ Delay, Event, Wait

## âœ… ì£¼ìš” ê°œë… íë¦„
Verilogì—ì„œ behavioral ëª¨ë¸ë§ ì‹œ **ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ ì œì–´**ë¥¼ ìœ„í•œ ì„¸ ê°€ì§€ íƒ€ì´ë° ì œì–´ ë°©ì‹ì´ ìˆë‹¤:

1. **Delay-based (`#`)**
2. **Event-based (`@`)**
3. **Level-sensitive (`wait`)**

ì´ë“¤ì„ í†µí•´ **ì‹¤í–‰ ì‹œì **ì„ ëª…í™•í•˜ê²Œ ì œì–´í•  ìˆ˜ ìˆìœ¼ë©°, íŠ¹íˆ **í…ŒìŠ¤íŠ¸ë²¤ì¹˜ë‚˜ ì´ˆê¸°í™” ì‹œë‚˜ë¦¬ì˜¤ êµ¬ì„±**ì—ì„œ ì¤‘ìš”í•˜ê²Œ ì‚¬ìš©ëœë‹¤.

---

## âœ… 1. Delay-based Timing Control (`#delay`)

### ğŸ¯ ê¸°ë³¸ ë¬¸ë²•
```verilog
#10 x = 1;         // 10 time units í›„ ì‹¤í–‰
#(a + b) y = 0;    // í‘œí˜„ì‹ ê¸°ë°˜ delay
```

### ğŸ¯ Intra-assignment delay (RHS ë¨¼ì € í‰ê°€ í›„ ì§€ì—°)
```verilog
y = #5 a + b;      // a+bëŠ” ì§€ê¸ˆ ê³„ì‚°, 5ë‹¨ìœ„ í›„ yì— í• ë‹¹
```

### ğŸ¯ ì˜ˆì‹œ
```verilog
initial begin
  x = 0;
  #10 y = 1;
  #latency z = 0;
  #(latency + delta) p = 1;
  #0 x = x + 1;  // ê°™ì€ ì‹œê°„ ë‚´ ìš°ì„ ìˆœìœ„ ì¡°ì •ìš© (ë¹„ê¶Œì¥)
end
```

---

## âœ… 2. Event-based Timing Control (`@event`)

### ğŸ¯ Regular event
```verilog
@(posedge clk) q = d;     // clk ìƒìŠ¹ì—£ì§€ì—ì„œ ì‹¤í–‰
@(negedge clk) q = d;     // clk í•˜ê°•ì—£ì§€ì—ì„œ ì‹¤í–‰
@(a or b or c) ...        // ì—¬ëŸ¬ ì‹ í˜¸ ë³€í™” ê°ì§€
```

### ğŸ¯ Named event
```verilog
event received;
->received;               // ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
@(received) ...           // ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ì‹¤í–‰
```

### ğŸ¯ Event OR (`@*`, `@(*)`)
```verilog
always @(*) begin
  out = a & b;   // ì½íˆëŠ” ëª¨ë“  ë³€ìˆ˜ ê°ì§€ ìë™ í¬í•¨
end
```

---

## âœ… 3. Level-sensitive Timing Control (`wait`)

### ğŸ¯ ì˜ˆì‹œ
```verilog
always
  wait (count_enable) #20 count = count + 1;
```

- ì¡°ê±´ì´ ë§Œì¡±ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ ì‹¤í–‰

---

## âœ… ì˜ˆì œ: D Flip-Flop (ë™ê¸° / ë¹„ë™ê¸°)
```verilog
// ë™ê¸° ë¦¬ì…‹
always @(posedge clk) begin
  if (rst) q <= 0;
  else     q <= d;
end

// ë¹„ë™ê¸° ë¦¬ì…‹
always @(posedge clk or posedge rst) begin
  if (rst) q <= 0;
  else     q <= d;
end
```

---

## âœ… Delay ì •ë¦¬ (Blocking vs Non-blocking)
| êµ¬ë¶„           | Blocking (`=`)                     | Non-blocking (`<=`)                   |
|----------------|------------------------------------|----------------------------------------|
| Inter-delay    | `#4 c = d; #8 e = f;` â†’ c, e ìˆœì°¨ ì‹¤í–‰ | `#4 c <= d; #8 e <= f;` â†’ ë³‘ë ¬ ì˜ˆì•½ë¨    |
| Intra-delay    | `c = #4 d; e = #8 f;` â†’ dëŠ” ì¦‰ì‹œ í‰ê°€ í›„ ì§€ì—° | `c <= #4 d; e <= #8 f;` â†’ ë™ì‹œ ì‹¤í–‰ ì˜ˆì•½ |
| Zero delay     | `#0` â†’ ì‹œê°„ ë‚´ ë§ˆì§€ë§‰ ì‹¤í–‰ ì˜ˆì•½        | í˜¼ë™ ë°œìƒ ê°€ëŠ¥, ê¶Œì¥í•˜ì§€ ì•ŠìŒ             |

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| ë°©ì‹        | í‚¤ì›Œë“œ     | íŠ¹ì§•                           | ìš©ë„                           |
|-------------|------------|--------------------------------|--------------------------------|
| Delay       | `#`        | ì‹œê°„ ë‹¨ìœ„ ì§€ì—°                  | ì´ˆê¸°í™”, ì‹œë®¬ë ˆì´ì…˜ ì‹œì  ì œì–´     |
| Event       | `@`        | ì‹ í˜¸ ë³€í™” ê°ì§€ë¡œ íŠ¸ë¦¬ê±°         | ë™ê¸°í™”, íŠ¸ë¦¬ê±° ì¡°ê±´ ì„¤ì •       |
| Wait        | `wait()`   | ì¡°ê±´ ë§Œì¡± ì‹œê¹Œì§€ ëŒ€ê¸°           | ì¡°ê±´ë¶€ ì‹¤í–‰, ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸  |
| ìë™ ê°ì§€    | `@(*)`, `@*` | ì¡°í•© ë…¼ë¦¬ ìë™ ê°ì§€ ë¦¬ìŠ¤íŠ¸ ìƒì„±   | ì¡°í•© íšŒë¡œ ì„¤ê³„ ìë™í™”          |

> âœ… delayëŠ” ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ìœ ìš©í•˜ì§€ë§Œ, **í•©ì„± ë¶ˆê°€ëŠ¥**í•œ ê²½ìš°ê°€ ë§ìœ¼ë¯€ë¡œ ì£¼ì˜í•´ì„œ ì‚¬ìš©í•´ì•¼ í•¨.

---

# 5. Conditional Statements â€“ if / if-else / nested if

## âœ… ì£¼ìš” ê°œë… íë¦„
Verilogì—ì„œ `if`, `if-else`, `if-else-if` ì¡°ê±´ë¬¸ì€ **íŠ¹ì • ì¡°ê±´ì— ë”°ë¼ ê°’ í• ë‹¹ ë° ë™ì‘ ë¶„ê¸°**ë¥¼ êµ¬í˜„í•œë‹¤.  
í•˜ì§€ë§Œ í•˜ë“œì›¨ì–´ì—ì„œëŠ” ì¡°ê±´ë¬¸ì´ **if ë¬¸ì²˜ëŸ¼ ì‹¤í–‰ë˜ì§€ ì•Šê³ **, ë³´í†µ **ë©€í‹°í”Œë ‰ì„œ(MUX)** íšŒë¡œë¡œ í•©ì„±ëœë‹¤.

---

## âœ… ê¸°ë³¸ ë¬¸ë²•

### ğŸ¯ Type 1: ë‹¨ì¼ if
```verilog
if (enable) out = in;
```

### ğŸ¯ Type 2: if-else
```verilog
if (a > b)
  max = a;
else
  max = b;
```

### ğŸ¯ Type 3: if-else-if (ë‹¤ì¤‘ ë¶„ê¸°)
```verilog
if (sel == 0)
  y = x + z;
else if (sel == 1)
  y = x - z;
else if (sel == 2)
  y = x * z;
else
  $display("Invalid sel");
```

---

## âœ… ì—¬ëŸ¬ ë¬¸ì¥ ê·¸ë£¹í•‘ (í•„ìˆ˜)
```verilog
if (valid) begin
  buffer = data;
  count = count + 1;
end else begin
  $display("Invalid input");
end
```

---

## âœ… í•˜ë“œì›¨ì–´ë¡œì˜ ì˜ë¯¸: MUX
- ì¡°ê±´ë¬¸ì€ ì‹¤í–‰ì„ â€œê±´ë„ˆë›°ëŠ” ê²ƒâ€ì´ ì•„ë‹ˆë¼, **ì–‘ìª½ ê²½ë¡œë¥¼ ëª¨ë‘ ê³„ì‚°**í•˜ê³  **ê²°ê³¼ë§Œ ì„ íƒ**
- ëª¨ë“  ê²½ë¡œê°€ ì‹¤ì œ íšŒë¡œë¡œ í•©ì„±ë¨

---

## âœ… ì˜ˆì‹œ: ì¡°í•© ë…¼ë¦¬ì—ì„œ ì¡°ê±´ë¬¸
```verilog
always @(*) begin
  if (sel == 2'b00) out = a;
  else if (sel == 2'b01) out = b;
  else if (sel == 2'b10) out = c;
  else out = d;
end
```

â†’ ì‹¤ì œë¡œëŠ” 4-to-1 MUX íšŒë¡œë¡œ êµ¬í˜„ë¨

---

## âœ… ì ì¬ì  ë¬¸ì œ: if ì¤‘ì²©
```verilog
if (a)
  if (b)
    if (c) out = d;
    else   out = ~d;
  else out = 1;
else out = 0;
```

- ì¤‘ì²© ì¡°ê±´ë¬¸ì€ **ê¸¸ê³  ë³µì¡í•œ MUX ì²´ì¸**ìœ¼ë¡œ í•©ì„±ë˜ì–´ **ì§€ì—°ì‹œê°„ ì¦ê°€** ê°€ëŠ¥ì„± ìˆìŒ

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| êµ¬ì¡°            | ì„¤ëª…                             | íšŒë¡œ ì˜ë¯¸               |
|-----------------|----------------------------------|--------------------------|
| `if`            | ì¡°ê±´ ì°¸ì¼ ë•Œ ì‹¤í–‰                | AND + MUX                |
| `if-else`       | ë‘˜ ì¤‘ í•˜ë‚˜ ì‹¤í–‰                  | 2-to-1 MUX               |
| `if-else-if`    | ë‹¤ì¤‘ ë¶„ê¸°                        | N-to-1 MUX               |
| ì¤‘ì²© if         | ì—¬ëŸ¬ ë‹¨ê³„ ì¡°ê±´ë¬¸ â†’ ì§€ì—° ì¦ê°€ ìœ„í—˜ | MUX ì²´ì¸ (ë¹„íš¨ìœ¨ì  ê°€ëŠ¥) |
| ë°˜ë“œì‹œ begin-end | ì—¬ëŸ¬ ë¬¸ì¥ì¼ ë•Œ í•„ìˆ˜               | ë¸”ë¡ ëª…í™•ì„± ìœ ì§€         |

> âœ… ì¡°ê±´ë¬¸ì€ ì‹¤ì œë¡œëŠ” **ëª¨ë“  ë¶„ê¸° ê²½ë¡œê°€ í•˜ë“œì›¨ì–´ë¡œ ìƒì„±**ë¨. â†’ ì „ë ¥/ìì› ì†Œëª¨ ì£¼ì˜!

---

# 6. Multi-way Branching â€“ case / casex / casez

## âœ… ì£¼ìš” ê°œë… íë¦„
ì¡°ê±´ì´ ì—¬ëŸ¬ ê°€ì§€ì¼ ë•Œ, `case` ë¬¸ì„ ì‚¬ìš©í•˜ë©´ **ê°€ë…ì„±ì´ ì¢‹ê³  ë³‘ë ¬ì  êµ¬ì¡°ì˜ MUX**ë¡œ í•©ì„±ëœë‹¤.  
Verilogì—ì„œëŠ” `case`, `casex`, `casez` ì„¸ ê°€ì§€ ë¬¸ë²•ì„ ì œê³µí•˜ë©°, ì…ë ¥ì˜ ê°’ì— ë”°ë¼ ë‹¤ì–‘í•œ ì‹¤í–‰ ê²½ë¡œë¥¼ ì„ íƒí•  ìˆ˜ ìˆë‹¤.

---

## âœ… ê¸°ë³¸ ë¬¸ë²•

### ğŸ¯ ì¼ë°˜ case ë¬¸
```verilog
case (sel)
  2'b00: out = a;
  2'b01: out = b;
  2'b10: out = c;
  2'b11: out = d;
  default: out = 1'bx;
endcase
```

- **expression**ì˜ ê°’ê³¼ ê° **case item**ì„ ë¹„êµ
- ì¼ì¹˜í•˜ëŠ” í•­ëª©ì˜ ë¬¸ì¥ì„ ì‹¤í–‰
- ì—†ìœ¼ë©´ `default` ì‹¤í–‰ (í•„ìˆ˜ ì•„ë‹˜ì´ì§€ë§Œ **ê°•ë ¥íˆ ê¶Œì¥**)

---

## âœ… casex / casez

| êµ¬ë¬¸     | ì˜ë¯¸                                      |
|----------|-------------------------------------------|
| `casex`  | **x, z ëª¨ë‘ ë¬´ì‹œ(don't care)**ë¡œ ì·¨ê¸‰     |
| `casez`  | **zë§Œ ë¬´ì‹œ**, xëŠ” ë¹„êµì— ì‚¬ìš©ë¨            |

### ğŸ¯ casex ì˜ˆì‹œ
```verilog
casex (code)
  4'b1xxx: y = 3;
  4'bx1xx: y = 2;
  4'bxx1x: y = 1;
  4'bxxx1: y = 0;
  default: y = 0;
endcase
```

- ì…ë ¥ ê°’ì— **xë‚˜ zê°€ ì„ì—¬ ìˆì–´ë„** ë™ì‘

---

## âœ… case vs if ë¹„êµ

| êµ¬ë¶„ | case ë¬¸ | if ë¬¸ |
|------|---------|--------|
| êµ¬ì¡° | ë³‘ë ¬ì  MUX | ì§ë ¬ì  ì¡°ê±´ ê²€ì‚¬ |
| í‘œí˜„ | ê°’ ê¸°ë°˜ ë¶„ê¸° | ë…¼ë¦¬ì‹ ê¸°ë°˜ ë¶„ê¸° |
| í•©ì„± | MUXë¡œ ê¹”ë”í•˜ê²Œ í•©ì„± | MUX ì²´ì¸ìœ¼ë¡œ í•©ì„± (ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŒ) |

---

## âœ… ì˜ˆì œ 1: MUX with case
```verilog
module mux4(out, a, b, c, d, sel);
  output reg out;
  input a, b, c, d;
  input [1:0] sel;

  always @(*) begin
    case (sel)
      2'b00: out = a;
      2'b01: out = b;
      2'b10: out = c;
      2'b11: out = d;
      default: out = 1'bx;
    endcase
  end
endmodule
```

---

## âœ… ì˜ˆì œ 2: Priority Encoder (casex)
```verilog
casex (data)
  8'b1xxxxxxx: code = 3'd7;
  8'b01xxxxxx: code = 3'd6;
  8'b001xxxxx: code = 3'd5;
  8'b0001xxxx: code = 3'd4;
  8'b00001xxx: code = 3'd3;
  8'b000001xx: code = 3'd2;
  8'b0000001x: code = 3'd1;
  8'b00000001: code = 3'd0;
  default:     code = 3'bxxx;
endcase
```

---

## âœ… ì˜ˆì œ 3: casez ì‚¬ìš©
```verilog
casez (instr)
  8'b1???: out = 1;
  8'b01??: out = 2;
  8'b001?: out = 3;
  8'b0001: out = 4;
  default: out = 0;
endcase
```

- `?`ëŠ” zì™€ ê°™ì€ ì˜ë¯¸ â†’ `casez`ì¼ ë•Œë§Œ ì‚¬ìš© ê°€ëŠ¥

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| êµ¬ë¬¸     | ë¹„êµ ëŒ€ìƒ       | donâ€™t care ì²˜ë¦¬ | í•˜ë“œì›¨ì–´ ì˜ë¯¸     |
|----------|------------------|------------------|--------------------|
| `case`   | ì •í™•íˆ ì¼ì¹˜       | âŒ               | MUX                |
| `casex`  | x, z ë¬´ì‹œ         | âœ… (x, z ëª¨ë‘ ë¬´ì‹œ) | MUX with don't care |
| `casez`  | zë§Œ ë¬´ì‹œ          | âœ… (zë§Œ don't care) | MUX with z ignore  |

> âœ… `case` ê³„ì—´ êµ¬ë¬¸ì€ **ë³‘ë ¬ì  ë¶„ê¸° êµ¬ì¡°ë¥¼ ê¹”ë”í•˜ê²Œ í‘œí˜„**í•  ìˆ˜ ìˆìœ¼ë©°, **ì¡°ê±´ì´ ë§ì„ìˆ˜ë¡ if ë¬¸ë³´ë‹¤ íš¨ìœ¨ì **ì´ë‹¤.

---

# 7. Loops â€“ while / for / repeat / forever

## âœ… ì£¼ìš” ê°œë… íë¦„
Verilogì—ì„œ ë°˜ë³µ ì‹¤í–‰ì„ ìœ„í•´ ì œê³µë˜ëŠ” ë„¤ ê°€ì§€ ë£¨í”„ ë¬¸ì€ ëª¨ë‘ **`initial` ë˜ëŠ” `always` ë¸”ë¡ ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥**í•˜ë‹¤.  
ì´ ë£¨í”„ë“¤ì€ ì‹œë®¬ë ˆì´ì…˜ ì œì–´, ë°ì´í„° ì´ˆê¸°í™”, í…ŒìŠ¤íŠ¸ë²¤ì¹˜ êµ¬ì„± ë“±ì—ì„œ ìœ ìš©í•˜ê²Œ ì‚¬ìš©ëœë‹¤.

---

## âœ… ë£¨í”„ ì¢…ë¥˜ ë° ë¬¸ë²• ìš”ì•½

| ì¢…ë¥˜     | ë¬¸ë²•                                | ì„¤ëª…                         |
|----------|-------------------------------------|------------------------------|
| `while`  | `while (cond) begin ... end`        | ì¡°ê±´ì´ ì°¸ì¸ ë™ì•ˆ ë°˜ë³µ        |
| `for`    | `for (init; cond; step) begin ... end` | ì •í•´ì§„ íšŸìˆ˜ë§Œí¼ ë°˜ë³µ        |
| `repeat` | `repeat (n) begin ... end`          | ê³ ì • íšŸìˆ˜ ë°˜ë³µ               |
| `forever`| `forever begin ... end`             | ë¬´í•œ ë°˜ë³µ (`$finish`ë¡œ ì¢…ë£Œ) |

---

## âœ… 1. while loop

### ğŸ¯ ê¸°ë³¸ ë¬¸ë²•
```verilog
while (condition) begin
  // ë°˜ë³µ ë‚´ìš©
end
```

### ğŸ¯ ì˜ˆì‹œ
```verilog
integer count = 0;
while (count < 128) begin
  $display("Count = %d", count);
  count = count + 1;
end
```

- ì¡°ê±´ì´ falseê°€ ë˜ë©´ ë£¨í”„ íƒˆì¶œ

---

## âœ… 2. for loop

### ğŸ¯ ê¸°ë³¸ ë¬¸ë²•
```verilog
for (i = 0; i < N; i = i + 1) begin
  // ë°˜ë³µ ë‚´ìš©
end
```

### ğŸ¯ ì˜ˆì‹œ
```verilog
integer state[0:9];
integer i;
for (i = 0; i < 10; i = i + 1) begin
  state[i] = 0;
end
```

- ì´ˆê¸°ê°’, ì¡°ê±´, ì¦ê°€ì‹ì„ í•¨ê»˜ í¬í•¨ â†’ ì»´íŒ©íŠ¸í•˜ê³  ê¹”ë”

---

## âœ… 3. repeat loop

### ğŸ¯ ê¸°ë³¸ ë¬¸ë²•
```verilog
repeat (N) begin
  // ë°˜ë³µ ë‚´ìš©
end
```

### ğŸ¯ ì˜ˆì‹œ
```verilog
integer count = 0;
repeat (64) begin
  $display("Count = %d", count);
  count = count + 1;
end
```

- ì¡°ê±´ ì—†ì´ **ì§€ì •ëœ íšŸìˆ˜ë§Œí¼ ë°˜ë³µ**

---

## âœ… 4. forever loop

### ğŸ¯ ê¸°ë³¸ ë¬¸ë²•
```verilog
forever begin
  // ë¬´í•œ ë°˜ë³µ
end
```

### ğŸ¯ ì˜ˆì‹œ 1: Clock ìƒì„±
```verilog
reg clk = 0;
initial forever #10 clk = ~clk;
```

### ğŸ¯ ì˜ˆì‹œ 2: ì´ë²¤íŠ¸ ê¸°ë°˜ ë°˜ë³µ
```verilog
initial forever @(posedge clk) x = y;
```

- ë¬´í•œ ë°˜ë³µì´ë¯€ë¡œ ë°˜ë“œì‹œ `$finish`ë‚˜ `disable`ë¡œ ì¢…ë£Œì‹œì¼œì•¼ í•¨

---

## âœ… ì‘ìš© ì˜ˆì‹œ: repeat + ì´ë²¤íŠ¸
```verilog
repeat (8) @(posedge clk) buffer[i] = data;
```
- í´ëŸ­ ì—£ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ 8ë²ˆ ë°ì´í„°ë¥¼ ë²„í¼ì— ì €ì¥

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| ë£¨í”„ íƒ€ì…   | ìš©ë„                        | ì¢…ë£Œ ì¡°ê±´         | íŠ¹ì§•                     |
|------------|-----------------------------|-------------------|--------------------------|
| `while`    | ì¡°ê±´ì´ ì°¸ì¼ ë•Œ ë°˜ë³µ         | ì¡°ê±´ ê±°ì§“ì¼ ë•Œ     | ê°€ì¥ ì¼ë°˜ì  ë°˜ë³µ êµ¬ì¡°     |
| `for`      | ì •í•´ì§„ íšŸìˆ˜ ë°˜ë³µ (index ê¸°ë°˜) | ì¡°ê±´ ê±°ì§“ì¼ ë•Œ     | ì»´íŒ©íŠ¸í•˜ê³  ê°€ë…ì„± ë†’ìŒ    |
| `repeat`   | ê³ ì • íšŸìˆ˜ ë°˜ë³µ              | ìë™ ì¢…ë£Œ         | í…ŒìŠ¤íŠ¸ë²¤ì¹˜ì—ì„œ ìì£¼ ì‚¬ìš© |
| `forever`  | ë¬´í•œ ë£¨í”„                   | ëª…ì‹œì  ì¢…ë£Œ í•„ìš”   | í´ëŸ­ ìƒì„± ë“±ì— ì‚¬ìš©       |

> âœ… ë£¨í”„ëŠ” **ì´ˆê¸°í™” ë° ì‹œë®¬ë ˆì´ì…˜ ì œì–´**ì— ìœ ìš©í•˜ì§€ë§Œ, **í•©ì„± ê°€ëŠ¥í•œ ì½”ë“œì—ì„œëŠ” ì£¼ì˜**í•´ì„œ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

---

# 8. Sequential and Parallel Blocks â€“ `begin-end` vs `fork-join`

## âœ… ì£¼ìš” ê°œë… íë¦„
Verilogì—ì„œ ì—¬ëŸ¬ ë¬¸ì¥ì„ í•˜ë‚˜ë¡œ ë¬¶ì–´ ì‹¤í–‰ ìˆœì„œ/ë™ì‹œì„±ì„ ì œì–´í•˜ê¸° ìœ„í•´ **block statement**ë¥¼ ì‚¬ìš©í•œë‹¤.  
ë¸”ë¡ì—ëŠ” ë‘ ì¢…ë¥˜ê°€ ìˆìœ¼ë©°, ì‹¤í–‰ ë°©ì‹ì´ ë‹¤ë¥´ë‹¤:

1. **Sequential block (`begin-end`)**: ìˆœì°¨ ì‹¤í–‰  
2. **Parallel block (`fork-join`)**: ë³‘ë ¬ ì‹¤í–‰

---

## âœ… 1. Sequential Block â€“ `begin ... end`

### ğŸ¯ íŠ¹ì§•
- ì•ˆì˜ ë¬¸ì¥ì„ **ìˆœì„œëŒ€ë¡œ ìˆœì°¨ ì‹¤í–‰**
- ê¸°ë³¸ ë¸”ë¡ êµ¬ì¡°ì´ë©°, ì¼ë°˜ì ìœ¼ë¡œ ë§ì´ ì‚¬ìš©ë¨

### ğŸ¯ ì˜ˆì‹œ
```verilog
initial begin
  x = 1'b0;           // time 0
  #5 y = 1'b1;        // time 5
  #10 z = {x, y};     // time 15
  #20 w = {y, x};     // time 35
end
```

---

## âœ… 2. Parallel Block â€“ `fork ... join`

### ğŸ¯ íŠ¹ì§•
- ì•ˆì˜ ë¬¸ì¥ì„ **ë™ì‹œì— ë³‘ë ¬ ì‹¤í–‰**
- ê° ë¬¸ì¥ì˜ ì‹¤í–‰ ì‹œê°„ì€ ê°œë³„ì ìœ¼ë¡œ ê´€ë¦¬ë¨

### ğŸ¯ ì˜ˆì‹œ
```verilog
initial fork
  x = 1'b0;            // time 0
  #5 y = 1'b1;         // time 5
  #10 z = {x, y};      // time 10
  #20 w = {y, x};      // time 20
join
```

- ì‹¤í–‰ ì‹œë®¬ë ˆì´ì…˜ íƒ€ì´ë°ì´ ì„œë¡œ ë‹¤ë¥´ê²Œ ì²˜ë¦¬ë¨

---

## âœ… Race Condition ì£¼ì˜

### ğŸ¯ ë‚˜ìœ ì˜ˆ (ë³‘ë ¬ ë¸”ë¡ ë‚´ ë ˆì´ìŠ¤)
```verilog
initial fork
  z = {x, y};
  w = {y, x};  // z, wê°€ ê°™ì€ ì‹œê°„ì— ë™ì‹œì— ê²°ì • â†’ ë¹„ê²°ì •ì„± ê°€ëŠ¥ì„±
join
```

- ë™ì¼ ì‹œê°„ì— ê°™ì€ ì‹ í˜¸ì— í• ë‹¹ â†’ ì‹œë®¬ë ˆì´í„°ë§ˆë‹¤ ë™ì‘ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŒ

---

## âœ… Named & Nested Blocks

### ğŸ¯ Named block
```verilog
initial begin : block1
  integer i;
  // block1.ië¡œ ì ‘ê·¼ ê°€ëŠ¥
end
```

### ğŸ¯ Nested block
```verilog
initial begin
  fork
    #5 y = 1;
    #10 z = {x, y};
  join
  #20 w = {y, x};
end
```

---

## âœ… disable ë¬¸ì„ í†µí•œ ë¸”ë¡ íƒˆì¶œ

### ğŸ¯ ì˜ˆì‹œ
```verilog
initial begin : block1
  while (i < 16) begin
    if (flag[i]) begin
      $display("True bit at %d", i);
      disable block1;  // ë°”ë¡œ ë¸”ë¡ íƒˆì¶œ
    end
    i = i + 1;
  end
end
```

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| ë¸”ë¡ ì¢…ë¥˜         | í‚¤ì›Œë“œ       | ì‹¤í–‰ ë°©ì‹        | ì£¼ìš” ìš©ë„                         |
|------------------|--------------|------------------|----------------------------------|
| Sequential Block | `begin-end`  | ìˆœì°¨ì  ì‹¤í–‰       | ê¸°ë³¸ì ì¸ ë¬¸ì¥ ê·¸ë£¹í•‘               |
| Parallel Block   | `fork-join`  | ë³‘ë ¬ì  ì‹¤í–‰       | ë³‘ë ¬ ë™ì‘, ì§€ì—° ì‹œê°„ ì‹¤í—˜ ë“±         |
| Named Block      | `begin:name` | ì´ë¦„ ì§€ì • ê°€ëŠ¥    | ê³„ì¸µì  ì°¸ì¡°, `disable`ë¡œ íƒˆì¶œ ê°€ëŠ¥ |
| Nested Block     | ë¸”ë¡ ì•ˆì˜ ë¸”ë¡ | ë¸”ë¡ ì¤‘ì²©        | êµ¬ì¡°ì  ì½”ë“œ êµ¬ì„±                   |

> âœ… `fork-join`ì€ ë³‘ë ¬ ì‹œë®¬ë ˆì´ì…˜ ì‹œ ìœ ìš©í•˜ì§€ë§Œ, **Race condition ì£¼ì˜** ë° **í•©ì„± ë¶ˆê°€** ì£¼ì˜ í•„ìš”!

---

# 9. Generate Blocks â€“ ë°˜ë³µì /ì¡°ê±´ì  í•˜ë“œì›¨ì–´ ìƒì„±

## âœ… ì£¼ìš” ê°œë… íë¦„
`generate` ë¸”ë¡ì€ Verilogì—ì„œ **ë°˜ë³µì  ë˜ëŠ” ì¡°ê±´ì  í•˜ë“œì›¨ì–´ êµ¬ì¡° ìƒì„±**ì— ì‚¬ìš©ë˜ëŠ” ë©”íƒ€ í”„ë¡œê·¸ë˜ë° ë„êµ¬ë‹¤.  
ì»´íŒŒì¼ ì‹œê°„(elaboration time)ì— ì½”ë“œê°€ ìƒì„±ë˜ë©°, **ë³µì¡í•œ êµ¬ì¡°ë¥¼ íŒŒë¼ë¯¸í„°í™”í•˜ì—¬ ê°„ê²°í•˜ê²Œ êµ¬í˜„**í•  ìˆ˜ ìˆë‹¤.

---

## âœ… ê¸°ë³¸ ë¬¸ë²•

```verilog
generate
  for (...) begin : block_name
    // ë°˜ë³µì  êµ¬ì¡° ìƒì„±
  end
endgenerate
```

- ë°˜ë“œì‹œ `generate`â€“`endgenerate`ë¡œ ê°ì‹¼ë‹¤
- ë‚´ë¶€ì—ì„œ `genvar`ë¡œ ì¸ë±ìŠ¤ ë³€ìˆ˜ ì„ ì–¸

---

## âœ… ì¢…ë¥˜ë³„ ì‚¬ìš© ë°©ì‹

| ìœ í˜•             | ì„¤ëª…                             | í‚¤ì›Œë“œ ì˜ˆì‹œ                |
|------------------|----------------------------------|-----------------------------|
| Generate Loop    | for ë£¨í”„ë¥¼ ì´ìš©í•œ ë°˜ë³µ êµ¬ì¡° ìƒì„± | `for (i=0; i<N; i++)`       |
| Generate If      | ì¡°ê±´ì— ë”°ë¼ ë‹¤ë¥¸ êµ¬ì¡° ìƒì„±        | `if (condition)`            |
| Generate Case    | case ë¶„ê¸°ë³„ êµ¬ì¡° ìƒì„±             | `case (param)`              |

---

## âœ… 1. Generate Loop ì˜ˆì‹œ â€“ Bitwise XOR

```verilog
module bitwise_xor(out, i0, i1);
  parameter N = 32;
  output [N-1:0] out;
  input  [N-1:0] i0, i1;

  genvar j;
  generate
    for (j = 0; j < N; j = j + 1) begin: xor_loop
      xor g1 (out[j], i0[j], i1[j]);
    end
  endgenerate
endmodule
```

- **í•˜ë“œì›¨ì–´ 32ê°œì˜ XOR ê²Œì´íŠ¸ë¥¼ ìë™ ìƒì„±**

---

## âœ… 2. Generate Loop ì˜ˆì‹œ â€“ Ripple Carry Adder

```verilog
generate
  for (i = 0; i < N; i = i + 1) begin: r_loop
    xor g1 (t1, a0[i], a1[i]);
    xor g2 (sum[i], t1, carry[i]);
    and g3 (t2, a0[i], a1[i]);
    and g4 (t3, t1, carry[i]);
    or  g5 (carry[i+1], t2, t3);
  end
endgenerate
```

- í•˜í”„/í’€ ê°€ì‚°ê¸° êµ¬ì¡°ë¥¼ `N`ë¹„íŠ¸ë¡œ í™•ì¥ ê°€ëŠ¥

---

## âœ… 3. Generate Conditional ì˜ˆì‹œ

```verilog
generate
  if (a0_width < 8 || a1_width < 8)
    cla_multiplier #(a0_width, a1_width) m0 (product, a0, a1);
  else
    tree_multiplier #(a0_width, a1_width) m0 (product, a0, a1);
endgenerate
```

- **ì…ë ¥ í­ì— ë”°ë¼ ë‹¤ë¥¸ ëª¨ë“ˆ ì¸ìŠ¤í„´ìŠ¤ ì‚¬ìš©**

---

## âœ… 4. Generate Case ì˜ˆì‹œ

```verilog
generate
  case (N)
    1: adder_1bit adder1(...);
    2: adder_2bit adder2(...);
    default: adder_cla #(N) adderN(...);
  endcase
endgenerate
```

- **íŒŒë¼ë¯¸í„° Nê°’ì— ë”°ë¼ êµ¬ì¡°ë¥¼ ì„ íƒì ìœ¼ë¡œ ìƒì„±**

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

| í‚¤ì›Œë“œ        | ì„¤ëª…                             | ì¡°ê±´/ë°˜ë³µ |
|---------------|----------------------------------|-----------|
| `generate`    | ë¸”ë¡ ì‹œì‘                         | ê³µí†µ ì‹œì‘ |
| `endgenerate` | ë¸”ë¡ ë                           | ê³µí†µ ë   |
| `genvar`      | generate ë£¨í”„ìš© ì¸ë±ìŠ¤ ì„ ì–¸       | ë°˜ë³µìš©    |
| `for`         | ë°˜ë³µ êµ¬ì¡° ìƒì„±                    | ë°˜ë³µ      |
| `if / else`   | ì¡°ê±´ì  êµ¬ì¡° ìƒì„± (ì»´íŒŒì¼ ì‹œê°„)     | ì¡°ê±´      |
| `case`        | ë‹¤ì¤‘ ì¡°ê±´ êµ¬ì¡° ìƒì„±               | ì¡°ê±´      |

> âœ… `generate` ë¬¸ì€ ì»´íŒŒì¼ íƒ€ì„ì— **Verilog êµ¬ì¡°ë¥¼ ë™ì ìœ¼ë¡œ ìƒì„±**í•  ìˆ˜ ìˆì–´,  
> íŒŒë¼ë¯¸í„°í™”ëœ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì„¤ê³„ë¥¼ ë§Œë“¤ ë•Œ ë§¤ìš° ìœ ìš©í•˜ë‹¤.

---

# 10. Examples â€“ Traffic Signal Controller

## âœ… ì˜ˆì œ ê°œìš”: ì‹ í˜¸ë“± ì œì–´ê¸° (Traffic Signal Controller)

### ğŸ¯ ë™ì‘ ëª…ì„¸
- **Main Highway**ëŠ” í•­ìƒ ì°¨ëŸ‰ì´ ë§ìŒ â†’ ê¸°ë³¸ì ìœ¼ë¡œ **Green ìœ ì§€**
- **Country Road**ì— ì°¨ëŸ‰ì´ ê°ì§€ë˜ë©´:
  - Main HighwayëŠ” **Yellow â†’ Red**ë¡œ ë°”ë€œ
  - Country RoadëŠ” **Red â†’ Green**ìœ¼ë¡œ ë°”ë€œ
- ì°¨ëŸ‰ì´ ëª¨ë‘ ì§€ë‚˜ê°€ë©´:
  - Country RoadëŠ” **Yellow â†’ Red**ë¡œ
  - Main HighwayëŠ” **Red â†’ Green**ìœ¼ë¡œ ë³µê·€

- **ì…ë ¥ X**: Country Roadì— ì°¨ëŸ‰ì´ ê°ì§€ë˜ë©´ 1, ì•„ë‹ˆë©´ 0

---

## âœ… ìƒíƒœ ë‹¤ì´ì–´ê·¸ë¨

```text
S0: Hwy=G, Cntry=R
 â†“ X=1
S1: Hwy=Y, Cntry=R
 â†“ (delay)
S2: Hwy=R, Cntry=R
 â†“ (delay)
S3: Hwy=R, Cntry=G
 â†“ X=0
S4: Hwy=R, Cntry=Y
 â†“ (delay)
S0: Hwy=G, Cntry=R
```

---

## âœ… ìƒíƒœ ì •ì˜ ë° ì „ì´ ì œì–´

```verilog
parameter RED = 2'd0, YELLOW = 2'd1, GREEN = 2'd2;
parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
```

---

## âœ… Verilog ì½”ë“œ ìš”ì•½

### â–ªï¸ ìƒíƒœ ë ˆì§€ìŠ¤í„°
```verilog
reg [2:0] state, next_state;

always @(posedge clock or posedge clear) begin
  if (clear) state <= S0;
  else       state <= next_state;
end
```

### â–ªï¸ ì¶œë ¥ ì œì–´ ë¡œì§
```verilog
always @(state) begin
  hwy = GREEN; cntry = RED; // ê¸°ë³¸ê°’
  case (state)
    S1: hwy = YELLOW;
    S2: hwy = RED;
    S3: cntry = GREEN;
    S4: cntry = YELLOW;
  endcase
end
```

### â–ªï¸ ìƒíƒœ ì „ì´ ë¡œì§
```verilog
always @(state or X) begin
  case (state)
    S0: next_state = (X) ? S1 : S0;
    S1: begin repeat (`Y2RDELAY) @(posedge clock); next_state = S2; end
    S2: begin repeat (`R2GDELAY) @(posedge clock); next_state = S3; end
    S3: next_state = (X) ? S3 : S4;
    S4: begin repeat (`Y2RDELAY) @(posedge clock); next_state = S0; end
    default: next_state = S0;
  endcase
end
```

---

## âœ… Stimulus ì˜ˆì‹œ (Testbench)

```verilog
initial begin
  CLEAR = 1'b1;
  repeat(5) @(negedge CLOCK);
  CLEAR = 1'b0;
end

initial begin
  CAR_ON_CNTRY_RD = 1'b0;
  repeat(20) @(negedge CLOCK); CAR_ON_CNTRY_RD = 1'b1;
  repeat(10) @(negedge CLOCK); CAR_ON_CNTRY_RD = 1'b0;
  // ë°˜ë³µì ìœ¼ë¡œ ì…ë ¥ ì‹œí€€ìŠ¤ ì œê³µ
  $stop;
end

initial forever #5 CLOCK = ~CLOCK;
```

---

## âœ… ì •ë¦¬ í¬ì¸íŠ¸

- ìƒíƒœ ê¸°ë°˜ ì„¤ê³„ ì˜ˆì œ
- `always @(posedge clock)` â†’ ìƒíƒœ ì—…ë°ì´íŠ¸
- `repeat(N) @(posedge clock)` â†’ ì‹œë®¬ë ˆì´ì…˜ ì§€ì—° êµ¬í˜„
- ì´ˆê¸°í™”: `CLEAR`, ì…ë ¥: `X`
- ì¶œë ¥ì€ ì‹ í˜¸ë“± ìƒíƒœ (`hwy`, `cntry`)ë¡œ í‘œí˜„

> âœ… ì´ ì˜ˆì œëŠ” FSM êµ¬í˜„, ìƒíƒœ ë¶„ê¸°, ì¶œë ¥ ì œì–´, íƒ€ì´ë° ì œì–´, í…ŒìŠ¤íŠ¸ë²¤ì¹˜ êµ¬ì„±ê¹Œì§€ **ëª¨ë“  behavioral ì„¤ê³„ í•µì‹¬ ìš”ì†Œ**ê°€ ì§‘ì•½ëœ ì¢‹ì€ ì˜ˆì‹œë‹¤.

---

# 11. Summary â€“ Behavioral Design í•µì‹¬ ìš”ì•½

## âœ… Behavioral Level Design í•µì‹¬ ì •ë¦¬

- **Behavioral Design**ì€ ê¸°ëŠ¥ ì¤‘ì‹¬ì˜ ê°€ì¥ ì¶”ìƒì ì¸ Verilog ì„¤ê³„ ìˆ˜ì¤€
- ì£¼ìš” êµ¬ì„±ìš”ì†Œ: `initial`, `always` ì ˆì°¨ì  ë¸”ë¡
- ëŒ€ë¶€ë¶„ ì‹œë®¬ë ˆì´ì…˜ì— ì í•©í•˜ë©°, í•©ì„± ê°€ëŠ¥ ì—¬ë¶€ëŠ” êµ¬ì¡°ì— ë”°ë¼ ë‹¤ë¦„

---

## âœ… ì£¼ìš” êµ¬ì„± ìš”ì†Œ ìš”ì•½

### ğŸ§± Structured Procedures
- `initial` â†’ í•œ ë²ˆ ì‹¤í–‰ (í…ŒìŠ¤íŠ¸ë²¤ì¹˜, ì´ˆê¸°í™”ìš©)
- `always` â†’ ë°˜ë³µ ì‹¤í–‰ (í•©ì„± ê°€ëŠ¥í•œ ë¸”ë¡)

### âš™ï¸ Procedural Assignments
- `=` â†’ Blocking: ìˆœì°¨ ì‹¤í–‰ (ì¡°í•© ë…¼ë¦¬)
- `<=` â†’ Non-blocking: ë³‘ë ¬ ì‹¤í–‰ (ìˆœì°¨ ë…¼ë¦¬)
- **í•œ ë¸”ë¡ì—ì„œ í˜¼ìš© ê¸ˆì§€**

### â±ï¸ Timing Controls
- `#delay` â†’ ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ ì§€ì—°
- `@event` â†’ ì‹ í˜¸ ë³€í™” ê°ì§€
- `wait()` â†’ ì¡°ê±´ ë§Œì¡± ì‹œ ì‹¤í–‰

### ğŸ”€ Conditional Statements
- `if`, `if-else`, `if-else-if`
- ì‹¤ì œ í•˜ë“œì›¨ì–´ì—ì„œëŠ” MUXë¡œ í•©ì„±

### ğŸ§® Multi-way Branching
- `case`, `casex`, `casez`
- ì¡°ê±´ì´ ë§ì„ìˆ˜ë¡ `if`ë³´ë‹¤ `case`ê°€ ë” ê¹”ë”í•¨

### ğŸ” Loops
- `while`, `for`, `repeat`, `forever`
- ë°˜ë“œì‹œ `initial` ë˜ëŠ” `always` ë¸”ë¡ ì•ˆì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥

### ğŸ”— Sequential & Parallel Blocks
- `begin-end`: ìˆœì°¨ ì‹¤í–‰
- `fork-join`: ë³‘ë ¬ ì‹¤í–‰ (Race condition ì£¼ì˜)
- `disable block_name`: ëª…ì‹œì  ì¢…ë£Œ

### ğŸ—ï¸ Generate Blocks
- `generate-endgenerate`ë¡œ ê°ìŒˆ
- ë°˜ë³µ êµ¬ì¡° (`for`), ì¡°ê±´ êµ¬ì¡° (`if`), ë¶„ê¸° êµ¬ì¡° (`case`) ìƒì„± ê°€ëŠ¥
- íŒŒë¼ë¯¸í„°í™”ëœ ëª¨ë“ˆ ì„¤ê³„ì— ì í•©

---

## âœ… ì‹¤ì „ ì˜ˆì‹œ
- **Traffic Signal Controller**ëŠ” FSM, ì¡°ê±´ ë¶„ê¸°, ì¶œë ¥ ì œì–´, íƒ€ì´ë° ì œì–´ë¥¼ ì¢…í•©ì ìœ¼ë¡œ ë‹¤ë£¬ ì˜ˆì œ

---

## âœ… ë§ˆë¬´ë¦¬ í•œì¤„ ìš”ì•½

> Behavioral Designì€ Verilogë¥¼ **ì•Œê³ ë¦¬ì¦˜ì²˜ëŸ¼ ì½”ë”©**í•  ìˆ˜ ìˆê²Œ í•´ì£¼ì§€ë§Œ,  
> ì‹¤ì œ íšŒë¡œ í•©ì„±ì„ ìœ„í•´ì„  **RTL ìˆ˜ì¤€ìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ ì½”ë“œì¸ì§€ í•­ìƒ ì£¼ì˜**í•´ì•¼ í•œë‹¤.